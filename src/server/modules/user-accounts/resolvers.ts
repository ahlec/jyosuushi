import { validate as validateEmail } from "email-validator";
import { GraphQLResolveInfo } from "graphql";

import { MIN_PASSWORD_LENGTH } from "@shared/constants";

/**
 * On new checkouts, you're going to be missing this file. This
 * is autogenerated and therefore not checked into the repository.
 * Generate this file automatically using `yarn gql:codegen`.
 */
import {
  LoginError,
  LoginPayload,
  LogoutError,
  LogoutPayload,
  Resolvers,
  UserAccount,
  MutationLoginArgs,
  MutationRegisterAccountArgs,
  RegisterAccountPayload,
  RegisterAccountError,
} from "@server/graphql.generated";

import {
  arePasswordsEqual,
  encryptPassword,
} from "@server/authorization/password-encryption";
import { ServerContext } from "@server/context";

import { logInUser } from "./utils";

const DIGIT_REGEX = /[0-9]/;

export const USER_ACCOUNTS_RESOLVERS: Resolvers = {
  Mutation: {
    login: async (
      parent: unknown,
      args: MutationLoginArgs,
      context: ServerContext,
      info: GraphQLResolveInfo
    ): Promise<LoginPayload> => {
      const { email, password } = args;
      const {
        authCookie,
        dataSources: { database },
        rateLimit,
      } = context;

      // Perform rate limiting
      const rateLimitError = await rateLimit(
        {
          args,
          context,
          info,
          parent,
        },
        {
          identityArgs: ["email"],
          regularWindow: {
            max: 5,
            window: "1m",
          },
          suspiciousRequestWindow: {
            max: 2,
            window: "1m",
          },
        }
      );
      if (rateLimitError) {
        return {
          error: LoginError.RateLimited,
        };
      }

      // Check to see if we're already authenticated
      if (authCookie.current && authCookie.current.valid) {
        return {
          error: LoginError.AlreadyAuthenticated,
        };
      }

      // Validate input parameters
      if (!email) {
        return {
          error: LoginError.EmailEmpty,
        };
      }

      if (!password) {
        return {
          error: LoginError.PasswordEmpty,
        };
      }

      // Fetch the account for the specified email
      const user = await database.getUserByEmail(email);
      if (!user) {
        return {
          error: LoginError.EmailPasswordCombinationIncorrect,
        };
      }

      const isMatchForPasswords = await arePasswordsEqual(
        user.encryptedPassword,
        password
      );
      if (!isMatchForPasswords) {
        return {
          error: LoginError.EmailPasswordCombinationIncorrect,
        };
      }

      // We've authenticated, so let's set up a new session
      await logInUser(user.id, authCookie, database);
      return {
        user: {
          dateRegistered: user.dateRegistered,
          username: user.email,
        },
      };
    },
    logout: async (
      parent: unknown,
      args: Record<string, unknown>,
      context: ServerContext,
      info: GraphQLResolveInfo
    ): Promise<LogoutPayload> => {
      const {
        authCookie,
        dataSources: { database },
        rateLimit,
      } = context;
      // Perform rate limiting
      const rateLimitError = await rateLimit(
        {
          args,
          context,
          info,
          parent,
        },
        {
          identityArgs: [],
          regularWindow: {
            max: 5,
            window: "1m",
          },
          suspiciousRequestWindow: {
            max: 2,
            window: "1m",
          },
        }
      );
      if (rateLimitError) {
        return {
          error: LogoutError.RateLimited,
        };
      }

      // Check to make sure we were even authenticated to begin with
      if (!authCookie.current) {
        return {
          error: LogoutError.WasntAuthenticated,
        };
      }

      // Clean up our session if we previously had a valid session
      if (authCookie.current.valid) {
        await database.endUserSession(authCookie.current.sessionId);
      }

      // Wipe our token and wrap up
      authCookie.delete();
      return {};
    },
    registerAccount: async (
      parent: unknown,
      args: MutationRegisterAccountArgs,
      context: ServerContext,
      info: GraphQLResolveInfo
    ): Promise<RegisterAccountPayload> => {
      const { email, password } = args;
      const {
        authCookie,
        dataSources: { database },
        rateLimit,
      } = context;

      // Perform rate limiting
      const rateLimitError = await rateLimit(
        {
          args,
          context,
          info,
          parent,
        },
        {
          identityArgs: ["email"],
          regularWindow: {
            max: 5,
            window: "1m",
          },
          suspiciousRequestWindow: {
            max: 2,
            window: "1m",
          },
        }
      );
      if (rateLimitError) {
        return {
          error: RegisterAccountError.RateLimited,
        };
      }

      // Check to see if we're already authenticated
      if (authCookie.current && authCookie.current.valid) {
        return {
          error: RegisterAccountError.AlreadyAuthenticated,
        };
      }

      // Validate email
      if (!email) {
        return {
          error: RegisterAccountError.EmailEmpty,
        };
      }

      if (!validateEmail(email)) {
        return {
          error: RegisterAccountError.EmailInvalidFormat,
        };
      }

      // Validate password
      if (password.length < MIN_PASSWORD_LENGTH) {
        return {
          error: RegisterAccountError.PasswordTooShort,
        };
      }

      if (!DIGIT_REGEX.test(password)) {
        return {
          error: RegisterAccountError.PasswordMissingNumeral,
        };
      }

      // Check to see if the user already exists
      const doesAccountAlreadyExist = await database.doesAccountExistForEmail(
        email
      );
      if (doesAccountAlreadyExist) {
        return {
          error: RegisterAccountError.AccountAlreadyExists,
        };
      }

      // Register the account
      const encryptedPassword = await encryptPassword(password);
      const newUser = await database.createUser(email, encryptedPassword);
      await logInUser(newUser.id, authCookie, database);
      return {
        user: {
          dateRegistered: newUser.dateRegistered,
          username: newUser.email,
        },
      };
    },
  },
  Query: {
    activeUser: async (
      _parent: unknown,
      _args: unknown,
      {
        authCookie: { current: userToken },
        dataSources: { database },
      }: ServerContext
    ): Promise<UserAccount | null> => {
      if (!userToken) {
        return null;
      }

      if (!userToken.valid) {
        console.log("validation error:", userToken.error);
        return null;
      }

      const user = await database.getUserById(userToken.userId);
      if (!user) {
        // This shouldn't be possible because of foreign key constraints in the
        // database, but let's quietly handle this as well.
        return null;
      }

      return {
        dateRegistered: user.dateRegistered,
        username: user.email,
      };
    },
  },
};
