import { validate as validateEmail } from "email-validator";

import { MIN_PASSWORD_LENGTH } from "@shared/constants";

/**
 * On new checkouts, you're going to be missing this file. This
 * is autogenerated and therefore not checked into the repository.
 * Generate this file automatically using `yarn gql:codegen`.
 */
import {
  Resolvers,
  UserAccount,
  MutationRegisterAccountArgs,
  RegisterAccountPayload,
  RegisterAccountError,
} from "@server/graphql.generated";

import { encryptPassword } from "@server/authorization/password-encryption";
import { ServerContext } from "@server/context";

const DIGIT_REGEX = /[0-9]/;

export const USER_ACCOUNTS_RESOLVERS: Resolvers = {
  Mutation: {
    registerAccount: async (
      _parent: unknown,
      { email, password }: MutationRegisterAccountArgs,
      { dataSources: { database }, userToken }: ServerContext
    ): Promise<RegisterAccountPayload> => {
      // Check to see if we're already authenticated
      if (userToken) {
        const validate = await userToken.validate();
        if (validate.valid) {
          return {
            error: RegisterAccountError.AlreadyAuthenticated,
          };
        }
      }

      // Validate email
      if (!email) {
        return {
          error: RegisterAccountError.EmailEmpty,
        };
      }

      if (!validateEmail(email)) {
        return {
          error: RegisterAccountError.EmailInvalidFormat,
        };
      }

      // Validate password
      if (password.length < MIN_PASSWORD_LENGTH) {
        return {
          error: RegisterAccountError.PasswordTooShort,
        };
      }

      if (!DIGIT_REGEX.test(password)) {
        return {
          error: RegisterAccountError.PasswordMissingNumeral,
        };
      }

      // Check to see if the user already exists
      const doesAccountAlreadyExist = await database.doesAccountExistForEmail(
        email
      );
      if (doesAccountAlreadyExist) {
        return {
          error: RegisterAccountError.AccountAlreadyExists,
        };
      }

      // Register the account
      const encryptedPassword = await encryptPassword(password);
      const newUser = await database.createUser(email, encryptedPassword);
      return {
        user: {
          dateRegistered: newUser.dateRegistered,
          username: newUser.email,
        },
      };
    },
  },
  Query: {
    activeUser: async (
      _parent: unknown,
      _args: unknown,
      { dataSources: { database }, userToken }: ServerContext
    ): Promise<UserAccount | null> => {
      if (!userToken) {
        console.log("nope");
        return null;
      }

      const validation = await userToken.validate();
      if (!validation.valid) {
        console.log("validation error:", validation.error);
        return null;
      }

      const user = await database.getUserById(validation.userSession.userId);
      if (!user) {
        // This shouldn't be possible because of foreign key constraints in the
        // database, but let's quietly handle this as well.
        return null;
      }

      return {
        dateRegistered: user.dateRegistered,
        username: user.email,
      };
    },
  },
};
